; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC131\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\AP -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;291      */
;;;292    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;293    {
;;;294        uint32_t u32PllFreq = 0, u32PllReg;
;;;295        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;296        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;297    
;;;298        u32PllReg = CLK->PLLCON;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;299    
;;;300        if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;301            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;302    
;;;303        if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
;;;304            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;305        else
;;;306            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;307    
;;;308        if(u32PllReg & CLK_PLLCON_BP_Msk)
;;;309            return u32FIN;      /* PLL is in bypass mode */
;;;310    
;;;311        /* PLL is output enabled in normal work mode */
;;;312        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
;;;313        u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
;;;314        u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
;;;315    
;;;316        /* u32FIN is shifted 2 bits to avoid overflow */
;;;317        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;318    
;;;319        return u32PllFreq;
;;;320    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;303
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;308
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;312
000026  0f92              LSRS     r2,r2,#30             ;312
000028  466b              MOV      r3,sp                 ;312
00002a  5c9b              LDRB     r3,[r3,r2]            ;312
00002c  05ca              LSLS     r2,r1,#23             ;313
00002e  0489              LSLS     r1,r1,#18             ;314
000030  0dd2              LSRS     r2,r2,#23             ;313
000032  0ec9              LSRS     r1,r1,#27             ;314
000034  1c89              ADDS     r1,r1,#2              ;314
000036  0880              LSRS     r0,r0,#2              ;317
000038  1c92              ADDS     r2,r2,#2              ;317
00003a  4359              MULS     r1,r3,r1              ;317
00003c  4350              MULS     r0,r2,r0              ;317
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;317
000044  bd08              POP      {r3,pc}
;;;321    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;515     */
;;;516    __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c1              LSLS     r1,r0,#27
;;;517    {
;;;518      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ec9              LSRS     r1,r1,#27
000004  2001              MOVS     r0,#1
000006  4088              LSLS     r0,r0,r1
000008  4901              LDR      r1,|L2.16|
00000a  6008              STR      r0,[r1,#0]
;;;519    }
00000c  4770              BX       lr
;;;520    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;503     */
;;;504    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c1              LSLS     r1,r0,#27
;;;505    {
;;;506      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ec9              LSRS     r1,r1,#27
000004  2001              MOVS     r0,#1
000006  4088              LSLS     r0,r0,r1
000008  4901              LDR      r1,|L3.16|
00000a  6008              STR      r0,[r1,#0]
;;;507    }
00000c  4770              BX       lr
;;;508    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0xe000e100

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;44      */
;;;45     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;46     {
000002  d503              BPL      |L4.12|
;;;47     
;;;48         if(u32InterruptFlag & UART_ISR_RLS_INT_Msk)   /* clear Receive Line Status Interrupt */
;;;49         {
;;;50             uart->FSR = UART_FSR_BIF_Msk | UART_FSR_FEF_Msk | UART_FSR_PEF_Msk;
000004  2270              MOVS     r2,#0x70
000006  6182              STR      r2,[r0,#0x18]
;;;51             uart->FSR = UART_FSR_RS485_ADD_DETF_Msk;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L4.12|
;;;52         }
;;;53     
;;;54         if(u32InterruptFlag & UART_ISR_MODEM_INT_Msk)  /* clear Modem Interrupt */
00000c  050a              LSLS     r2,r1,#20
00000e  d503              BPL      |L4.24|
;;;55             uart->MSR |= UART_MSR_DCTSF_Msk;
000010  6942              LDR      r2,[r0,#0x14]
000012  2301              MOVS     r3,#1
000014  431a              ORRS     r2,r2,r3
000016  6142              STR      r2,[r0,#0x14]
                  |L4.24|
;;;56     
;;;57         if(u32InterruptFlag & UART_ISR_BUF_ERR_INT_Msk)   /* clear Buffer Error Interrupt */
000018  048a              LSLS     r2,r1,#18
00001a  d501              BPL      |L4.32|
;;;58         {
;;;59             uart->FSR = UART_FSR_RX_OVER_IF_Msk | UART_FSR_TX_OVER_IF_Msk;
00001c  4a09              LDR      r2,|L4.68|
00001e  6182              STR      r2,[r0,#0x18]
                  |L4.32|
;;;60         }
;;;61     
;;;62         if(u32InterruptFlag & UART_ISR_CTSWKIF_Msk)   /* clear CTS Wake-up Interrupt */
000020  03ca              LSLS     r2,r1,#15
000022  d502              BPL      |L4.42|
;;;63         {
;;;64             uart->ISR = UART_ISR_CTSWKIF_Msk;
000024  2201              MOVS     r2,#1
000026  0412              LSLS     r2,r2,#16
000028  61c2              STR      r2,[r0,#0x1c]
                  |L4.42|
;;;65         }
;;;66     
;;;67         if(u32InterruptFlag & UART_ISR_DATWKIF_Msk)   /* clear Data Wake-up Interrupt */
00002a  038a              LSLS     r2,r1,#14
00002c  d502              BPL      |L4.52|
;;;68         {
;;;69             uart->ISR = UART_ISR_DATWKIF_Msk;
00002e  2201              MOVS     r2,#1
000030  0452              LSLS     r2,r2,#17
000032  61c2              STR      r2,[r0,#0x1c]
                  |L4.52|
;;;70         }
;;;71     
;;;72         if(u32InterruptFlag & UART_ISR_LIN_INT_Msk)   /* clear LIN bus Interrupt */
000034  0409              LSLS     r1,r1,#16
000036  d503              BPL      |L4.64|
;;;73         {
;;;74             uart->ISR = UART_ISR_LIN_IF_Msk;
000038  2180              MOVS     r1,#0x80
00003a  61c1              STR      r1,[r0,#0x1c]
;;;75             uart->LIN_SR = UART_LIN_SR_BIT_ERR_F_Msk   | UART_LIN_SR_LINS_BKDET_F_Msk  |
00003c  4902              LDR      r1,|L4.72|
00003e  6381              STR      r1,[r0,#0x38]
                  |L4.64|
;;;76                            UART_LIN_SR_LINS_SYNC_F_Msk | UART_LIN_SR_LINS_IDPERR_F_Msk |
;;;77                            UART_LIN_SR_LINS_HERR_F_Msk | UART_LIN_SR_LINS_HDET_F_Msk ;
;;;78         }
;;;79     
;;;80     }
000040  4770              BX       lr
;;;81     
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x01000001
                  |L4.72|
                          DCD      0x0000030f

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;90      */
;;;91     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;92     {
;;;93         uart->IER = 0;
000002  6041              STR      r1,[r0,#4]
;;;94     }
000004  4770              BX       lr
;;;95     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;105     */
;;;106    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;107    {
;;;108        uart->IER &= ~(UART_IER_AUTO_RTS_EN_Msk | UART_IER_AUTO_CTS_EN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;109    }
00000a  4770              BX       lr
;;;110    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=2

                  UART_DisableInt PROC
;;;130     */
;;;131    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  b510              PUSH     {r4,lr}
;;;132    {
;;;133        /* Disable UART specified interrupt */
;;;134        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  6842              LDR      r2,[r0,#4]
000004  438a              BICS     r2,r2,r1
000006  6042              STR      r2,[r0,#4]
;;;135    
;;;136        /* Disable NVIC UART IRQ */
;;;137        if(uart == UART0)
000008  490d              LDR      r1,|L7.64|
00000a  4288              CMP      r0,r1
00000c  d009              BEQ      |L7.34|
;;;138            NVIC_DisableIRQ(UART02_IRQn);
;;;139        else if(uart == UART1)
00000e  490d              LDR      r1,|L7.68|
000010  4288              CMP      r0,r1
000012  d103              BNE      |L7.28|
;;;140            NVIC_DisableIRQ(UART1_IRQn);
000014  200d              MOVS     r0,#0xd
                  |L7.22|
000016  f7fffffe          BL       NVIC_DisableIRQ
;;;141        else if(uart == UART2)
;;;142            NVIC_DisableIRQ(UART02_IRQn);
;;;143        else if(uart == UART3)
;;;144            NVIC_DisableIRQ(UART3_IRQn);
;;;145        else if(uart == UART4)
;;;146            NVIC_DisableIRQ(UART4_IRQn);
;;;147        else
;;;148            NVIC_DisableIRQ(UART5_IRQn);
;;;149    }
00001a  bd10              POP      {r4,pc}
                  |L7.28|
00001c  490a              LDR      r1,|L7.72|
00001e  4288              CMP      r0,r1                 ;141
000020  d101              BNE      |L7.38|
                  |L7.34|
000022  200c              MOVS     r0,#0xc               ;142
000024  e7f7              B        |L7.22|
                  |L7.38|
000026  4909              LDR      r1,|L7.76|
000028  4288              CMP      r0,r1                 ;143
00002a  d101              BNE      |L7.48|
00002c  200f              MOVS     r0,#0xf               ;144
00002e  e7f2              B        |L7.22|
                  |L7.48|
000030  4907              LDR      r1,|L7.80|
000032  4288              CMP      r0,r1                 ;145
000034  d101              BNE      |L7.58|
000036  2010              MOVS     r0,#0x10              ;146
000038  e7ed              B        |L7.22|
                  |L7.58|
00003a  2011              MOVS     r0,#0x11              ;148
00003c  e7eb              B        |L7.22|
;;;150    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x40050000
                  |L7.68|
                          DCD      0x40150000
                  |L7.72|
                          DCD      0x40154000
                  |L7.76|
                          DCD      0x40054000
                  |L7.80|
                          DCD      0x40058000

                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;160     */
;;;161    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;162    {
;;;163        /* Set RTS pin output is low level active */
;;;164        uart->MCR |= UART_MCR_LEV_RTS_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;165    
;;;166        /* Set CTS pin input is low level active */
;;;167        uart->MSR |= UART_MSR_LEV_CTS_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;168    
;;;169        /* Set RTS and CTS auto flow control enable */
;;;170        uart->IER |= UART_IER_AUTO_RTS_EN_Msk | UART_IER_AUTO_CTS_EN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;171    }
00001c  4770              BX       lr
;;;172    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=2

                  UART_EnableInt PROC
;;;192     */
;;;193    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195    
;;;196        /* Enable UART specified interrupt */
;;;197        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  6842              LDR      r2,[r0,#4]
000004  430a              ORRS     r2,r2,r1
000006  6042              STR      r2,[r0,#4]
;;;198    
;;;199        /* Enable NVIC UART IRQ */
;;;200        if(uart == UART0)
000008  490d              LDR      r1,|L9.64|
00000a  4288              CMP      r0,r1
00000c  d009              BEQ      |L9.34|
;;;201            NVIC_EnableIRQ(UART02_IRQn);
;;;202        else if(uart == UART1)
00000e  490d              LDR      r1,|L9.68|
000010  4288              CMP      r0,r1
000012  d103              BNE      |L9.28|
;;;203            NVIC_EnableIRQ(UART1_IRQn);
000014  200d              MOVS     r0,#0xd
                  |L9.22|
000016  f7fffffe          BL       NVIC_EnableIRQ
;;;204        else if(uart == UART2)
;;;205            NVIC_EnableIRQ(UART02_IRQn);
;;;206        else if(uart == UART3)
;;;207            NVIC_EnableIRQ(UART3_IRQn);
;;;208        else if(uart == UART4)
;;;209            NVIC_EnableIRQ(UART4_IRQn);
;;;210        else
;;;211            NVIC_EnableIRQ(UART5_IRQn);
;;;212    
;;;213    }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  490a              LDR      r1,|L9.72|
00001e  4288              CMP      r0,r1                 ;204
000020  d101              BNE      |L9.38|
                  |L9.34|
000022  200c              MOVS     r0,#0xc               ;205
000024  e7f7              B        |L9.22|
                  |L9.38|
000026  4909              LDR      r1,|L9.76|
000028  4288              CMP      r0,r1                 ;206
00002a  d101              BNE      |L9.48|
00002c  200f              MOVS     r0,#0xf               ;207
00002e  e7f2              B        |L9.22|
                  |L9.48|
000030  4907              LDR      r1,|L9.80|
000032  4288              CMP      r0,r1                 ;208
000034  d101              BNE      |L9.58|
000036  2010              MOVS     r0,#0x10              ;209
000038  e7ed              B        |L9.22|
                  |L9.58|
00003a  2011              MOVS     r0,#0x11              ;211
00003c  e7eb              B        |L9.22|
;;;214    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0x40050000
                  |L9.68|
                          DCD      0x40150000
                  |L9.72|
                          DCD      0x40154000
                  |L9.76|
                          DCD      0x40054000
                  |L9.80|
                          DCD      0x40058000

                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;225     */
;;;226    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;229        uint32_t u32ClkTbl[4] = {__HXT, 0, 0, __HIRC};
000004  481c              LDR      r0,|L10.120|
000006  460d              MOV      r5,r1                 ;227
000008  c80f              LDM      r0,{r0-r3}
00000a  b085              SUB      sp,sp,#0x14           ;227
00000c  466e              MOV      r6,sp
00000e  c60f              STM      r6!,{r0-r3}
;;;230        uint32_t u32Baud_Div = 0;
;;;231    
;;;232        /* Get UART clock source selection */
;;;233        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000010  481a              LDR      r0,|L10.124|
000012  6941              LDR      r1,[r0,#0x14]
;;;234    
;;;235        /* Get UART clock divider number */
;;;236        u8UartClkDivNum = (CLK->CLKDIV & CLK_CLKDIV_UART_N_Msk) >> CLK_CLKDIV_UART_N_Pos;
000014  6980              LDR      r0,[r0,#0x18]
;;;237    
;;;238        /* Select UART function */
;;;239        uart->FUN_SEL = UART_FUNC_SEL_UART;
;;;240    
;;;241        /* Set UART line configuration */
;;;242        uart->LCR = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
;;;243    
;;;244        /* Set UART Rx and RTS trigger level */
;;;245        uart->FCR &= ~(UART_FCR_RFITL_Msk | UART_FCR_RTS_TRI_LEV_Msk);
;;;246    
;;;247        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;248        if(u8UartClkSrcSel == 1)
;;;249            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;250    
;;;251        /* Set UART baud rate */
;;;252        if(u32baudrate != 0)
;;;253        {
;;;254            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate);
;;;255    
;;;256            if(u32Baud_Div > 0xFFFF)
;;;257                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate));
;;;258            else
;;;259                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;260        }
;;;261    }
000016  018a              LSLS     r2,r1,#6
000018  2103              MOVS     r1,#3
00001a  0f96              LSRS     r6,r2,#30
00001c  0500              LSLS     r0,r0,#20
00001e  0f07              LSRS     r7,r0,#28
000020  2000              MOVS     r0,#0                 ;239
000022  6320              STR      r0,[r4,#0x30]         ;239
000024  60e1              STR      r1,[r4,#0xc]          ;242
000026  68a0              LDR      r0,[r4,#8]            ;245
000028  4915              LDR      r1,|L10.128|
00002a  4008              ANDS     r0,r0,r1              ;245
00002c  60a0              STR      r0,[r4,#8]            ;245
00002e  2e01              CMP      r6,#1                 ;248
000030  d102              BNE      |L10.56|
000032  f7fffffe          BL       CLK_GetPLLClockFreq
000036  9001              STR      r0,[sp,#4]            ;249
                  |L10.56|
000038  2d00              CMP      r5,#0                 ;252
00003a  d01b              BEQ      |L10.116|
00003c  00b1              LSLS     r1,r6,#2              ;254
00003e  4668              MOV      r0,sp                 ;254
000040  5840              LDR      r0,[r0,r1]            ;254
000042  1c79              ADDS     r1,r7,#1              ;254
000044  f7fffffe          BL       __aeabi_uidivmod
000048  4606              MOV      r6,r0                 ;254
00004a  0869              LSRS     r1,r5,#1              ;254
00004c  1840              ADDS     r0,r0,r1              ;254
00004e  4629              MOV      r1,r5                 ;254
000050  f7fffffe          BL       __aeabi_uidivmod
000054  490b              LDR      r1,|L10.132|
000056  1e80              SUBS     r0,r0,#2              ;256
000058  4288              CMP      r0,r1                 ;256
00005a  d907              BLS      |L10.108|
00005c  00e9              LSLS     r1,r5,#3              ;257
00005e  1870              ADDS     r0,r6,r1              ;257
000060  4629              MOV      r1,r5                 ;257
000062  f7fffffe          BL       __aeabi_uidivmod
000066  0900              LSRS     r0,r0,#4              ;257
000068  1e80              SUBS     r0,r0,#2              ;257
00006a  e002              B        |L10.114|
                  |L10.108|
00006c  2103              MOVS     r1,#3                 ;259
00006e  0709              LSLS     r1,r1,#28             ;259
000070  4308              ORRS     r0,r0,r1              ;259
                  |L10.114|
000072  6260              STR      r0,[r4,#0x24]         ;259
                  |L10.116|
000074  b005              ADD      sp,sp,#0x14
000076  bdf0              POP      {r4-r7,pc}
;;;262    
                          ENDP

                  |L10.120|
                          DCD      ||.constdata||
                  |L10.124|
                          DCD      0x50000200
                  |L10.128|
                          DCD      0xfff0ff0f
                  |L10.132|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;274     */
;;;275    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;276    {
000002  4604              MOV      r4,r0
;;;277        uint32_t  u32Count, u32delayno;
;;;278    
;;;279        for(u32Count = 0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;280        {
;;;281            u32delayno = 0;
;;;282    
;;;283            while(uart->FSR & UART_FSR_RX_EMPTY_Msk)   /* Check RX empty => failed */
;;;284            {
;;;285                u32delayno++;
;;;286                if(u32delayno >= 0x40000000)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L11.38|
                  |L11.12|
00000c  2300              MOVS     r3,#0                 ;281
00000e  e004              B        |L11.26|
                  |L11.16|
000010  1c5b              ADDS     r3,r3,#1              ;283
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L11.26|
;;;287                    return FALSE;
000016  2000              MOVS     r0,#0
;;;288            }
;;;289            pu8RxBuf[u32Count] = uart->RBR;    /* Get Data from UART RX  */
;;;290        }
;;;291    
;;;292        return u32Count;
;;;293    
;;;294    }
000018  bd70              POP      {r4-r6,pc}
                  |L11.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;283
00001c  0476              LSLS     r6,r6,#17             ;283
00001e  d4f7              BMI      |L11.16|
000020  6823              LDR      r3,[r4,#0]            ;289
000022  540b              STRB     r3,[r1,r0]            ;289
000024  1c40              ADDS     r0,r0,#1              ;289
                  |L11.38|
000026  4290              CMP      r0,r2                 ;279
000028  d3f0              BCC      |L11.12|
00002a  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;388     */
;;;389    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;390    {
000002  4604              MOV      r4,r0
;;;391        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;392        uint32_t u32ClkTbl[4] = {__HXT, 0, 0, __HIRC};
000004  481c              LDR      r0,|L12.120|
000006  b084              SUB      sp,sp,#0x10           ;390
000008  c80f              LDM      r0,{r0-r3}
;;;393        uint32_t u32Baud_Div;
;;;394    
;;;395        /* Select IrDA function mode */
;;;396        uart->FUN_SEL = UART_FUNC_SEL_IrDA;
00000a  466d              MOV      r5,sp
00000c  c50f              STM      r5!,{r0-r3}
00000e  2602              MOVS     r6,#2
000010  6326              STR      r6,[r4,#0x30]
;;;397    
;;;398        /* Get UART clock source selection */
;;;399        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000012  481a              LDR      r0,|L12.124|
000014  6941              LDR      r1,[r0,#0x14]
;;;400    
;;;401        /* Get UART clock divider number */
;;;402        u8UartClkDivNum = (CLK->CLKDIV & CLK_CLKDIV_UART_N_Msk) >> CLK_CLKDIV_UART_N_Pos;
000016  6980              LDR      r0,[r0,#0x18]
;;;403    
;;;404        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;405        if(u8UartClkSrcSel == 1)
;;;406            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;407    
;;;408        /* Set UART IrDA baud rate in mode 0 */
;;;409        if(u32Buadrate != 0)
;;;410        {
;;;411            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Buadrate);
;;;412    
;;;413            if(u32Baud_Div < 0xFFFF)
;;;414                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;415        }
;;;416    
;;;417        /* Configure IrDA relative settings */
;;;418        if(u32Direction == UART_IRCR_RX_SELECT)
;;;419        {
;;;420            uart->IRCR |= UART_IRCR_INV_RX_Msk;     //Rx signal is inverse
;;;421            uart->IRCR &= ~UART_IRCR_TX_SELECT_Msk;
;;;422        }
;;;423        else
;;;424        {
;;;425            uart->IRCR &= ~UART_IRCR_INV_TX_Msk;    //Tx signal is not inverse
;;;426            uart->IRCR |= UART_IRCR_TX_SELECT_Msk;
;;;427        }
;;;428    }
000018  0189              LSLS     r1,r1,#6
00001a  0f8d              LSRS     r5,r1,#30
00001c  0500              LSLS     r0,r0,#20
00001e  0f07              LSRS     r7,r0,#28
000020  2d01              CMP      r5,#1                 ;405
000022  d102              BNE      |L12.42|
000024  f7fffffe          BL       CLK_GetPLLClockFreq
000028  9001              STR      r0,[sp,#4]            ;406
                  |L12.42|
00002a  9805              LDR      r0,[sp,#0x14]         ;409
00002c  2800              CMP      r0,#0                 ;409
00002e  d011              BEQ      |L12.84|
000030  00a9              LSLS     r1,r5,#2              ;411
000032  4668              MOV      r0,sp                 ;411
000034  5840              LDR      r0,[r0,r1]            ;411
000036  1c79              ADDS     r1,r7,#1              ;411
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  9905              LDR      r1,[sp,#0x14]         ;411
00003e  00c9              LSLS     r1,r1,#3              ;411
000040  1840              ADDS     r0,r0,r1              ;411
000042  9905              LDR      r1,[sp,#0x14]         ;411
000044  f7fffffe          BL       __aeabi_uidivmod
000048  0900              LSRS     r0,r0,#4              ;411
00004a  490d              LDR      r1,|L12.128|
00004c  1e80              SUBS     r0,r0,#2              ;413
00004e  4288              CMP      r0,r1                 ;413
000050  d200              BCS      |L12.84|
000052  6260              STR      r0,[r4,#0x24]         ;414
                  |L12.84|
000054  9806              LDR      r0,[sp,#0x18]         ;418
000056  2800              CMP      r0,#0                 ;418
000058  6aa0              LDR      r0,[r4,#0x28]         ;425
00005a  d007              BEQ      |L12.108|
00005c  2120              MOVS     r1,#0x20              ;425
00005e  4388              BICS     r0,r0,r1              ;425
000060  62a0              STR      r0,[r4,#0x28]         ;425
000062  6aa0              LDR      r0,[r4,#0x28]         ;426
000064  4330              ORRS     r0,r0,r6              ;426
                  |L12.102|
000066  62a0              STR      r0,[r4,#0x28]         ;421
000068  b007              ADD      sp,sp,#0x1c
00006a  bdf0              POP      {r4-r7,pc}
                  |L12.108|
00006c  2140              MOVS     r1,#0x40              ;420
00006e  4308              ORRS     r0,r0,r1              ;420
000070  62a0              STR      r0,[r4,#0x28]         ;420
000072  6aa0              LDR      r0,[r4,#0x28]         ;421
000074  43b0              BICS     r0,r0,r6              ;421
000076  e7f6              B        |L12.102|
;;;429    
                          ENDP

                  |L12.120|
                          DCD      ||.constdata||+0x20
                  |L12.124|
                          DCD      0x50000200
                  |L12.128|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;469     */
;;;470    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;471    {
;;;472        /* Select LIN function mode */
;;;473        uart->FUN_SEL = UART_FUNC_SEL_LIN;
000002  2301              MOVS     r3,#1
000004  6303              STR      r3,[r0,#0x30]
;;;474    
;;;475        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;476        uart->ALT_CSR &= ~(UART_ALT_CSR_LIN_TX_EN_Msk | UART_ALT_CSR_LIN_RX_EN_Msk | UART_ALT_CSR_UA_LIN_BKFL_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  24cf              MOVS     r4,#0xcf
00000a  43a3              BICS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;477        uart->ALT_CSR |= (u32Mode | (u32BreakLength << UART_ALT_CSR_UA_LIN_BKFL_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  4311              ORRS     r1,r1,r2
000012  430b              ORRS     r3,r3,r1
000014  62c3              STR      r3,[r0,#0x2c]
;;;478    }
000016  bd10              POP      {r4,pc}
;;;479    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;444     */
;;;445    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;446    {
;;;447        /* Select UART RS485 function mode */
;;;448        uart->FUN_SEL = UART_FUNC_SEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;449    
;;;450        /* Set RS585 configuration */
;;;451        uart->ALT_CSR &= ~(UART_ALT_CSR_RS485_NMM_Msk | UART_ALT_CSR_RS485_AUD_Msk | UART_ALT_CSR_RS485_AAD_Msk | UART_ALT_CSR_ADDR_MATCH_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L14.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;452        uart->ALT_CSR |= (u32Mode | (u32Addr << UART_ALT_CSR_ADDR_MATCH_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0612              LSLS     r2,r2,#24
000012  430a              ORRS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  62c3              STR      r3,[r0,#0x2c]
;;;453    }
000018  bd10              POP      {r4,pc}
;;;454    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;323     */
;;;324    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;325    {
000002  4605              MOV      r5,r0
;;;326        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;327        uint32_t u32ClkTbl[4] = {__HXT, 0, 0, __HIRC};
000004  481b              LDR      r0,|L15.116|
000006  460c              MOV      r4,r1                 ;325
000008  c80f              LDM      r0,{r0-r3}
00000a  b085              SUB      sp,sp,#0x14           ;325
00000c  466e              MOV      r6,sp
00000e  c60f              STM      r6!,{r0-r3}
;;;328        uint32_t u32Baud_Div = 0;
;;;329    
;;;330        /* Get UART clock source selection */
;;;331        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000010  4819              LDR      r0,|L15.120|
000012  6941              LDR      r1,[r0,#0x14]
;;;332    
;;;333        /* Get UART clock divider number */
;;;334        u8UartClkDivNum = (CLK->CLKDIV & CLK_CLKDIV_UART_N_Msk) >> CLK_CLKDIV_UART_N_Pos;
000014  6980              LDR      r0,[r0,#0x18]
;;;335    
;;;336        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;337        if(u8UartClkSrcSel == 1)
;;;338            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;339    
;;;340        /* Set UART baud rate */
;;;341        if(u32baudrate != 0)
;;;342        {
;;;343            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate);
;;;344    
;;;345            if(u32Baud_Div > 0xFFFF)
;;;346                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate));
;;;347            else
;;;348                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;349        }
;;;350    
;;;351        /* Set UART line configuration */
;;;352        uart->LCR = u32data_width | u32parity | u32stop_bits;
;;;353    }
000016  0189              LSLS     r1,r1,#6
000018  0f8e              LSRS     r6,r1,#30
00001a  0500              LSLS     r0,r0,#20
00001c  0f07              LSRS     r7,r0,#28
00001e  2e01              CMP      r6,#1                 ;337
000020  d102              BNE      |L15.40|
000022  f7fffffe          BL       CLK_GetPLLClockFreq
000026  9001              STR      r0,[sp,#4]            ;338
                  |L15.40|
000028  2c00              CMP      r4,#0                 ;341
00002a  d01b              BEQ      |L15.100|
00002c  00b1              LSLS     r1,r6,#2              ;343
00002e  4668              MOV      r0,sp                 ;343
000030  5840              LDR      r0,[r0,r1]            ;343
000032  1c79              ADDS     r1,r7,#1              ;343
000034  f7fffffe          BL       __aeabi_uidivmod
000038  4606              MOV      r6,r0                 ;343
00003a  0861              LSRS     r1,r4,#1              ;343
00003c  1840              ADDS     r0,r0,r1              ;343
00003e  4621              MOV      r1,r4                 ;343
000040  f7fffffe          BL       __aeabi_uidivmod
000044  490d              LDR      r1,|L15.124|
000046  1e80              SUBS     r0,r0,#2              ;345
000048  4288              CMP      r0,r1                 ;345
00004a  d907              BLS      |L15.92|
00004c  00e1              LSLS     r1,r4,#3              ;346
00004e  1870              ADDS     r0,r6,r1              ;346
000050  4621              MOV      r1,r4                 ;346
000052  f7fffffe          BL       __aeabi_uidivmod
000056  0900              LSRS     r0,r0,#4              ;346
000058  1e80              SUBS     r0,r0,#2              ;346
00005a  e002              B        |L15.98|
                  |L15.92|
00005c  2103              MOVS     r1,#3                 ;348
00005e  0709              LSLS     r1,r1,#28             ;348
000060  4308              ORRS     r0,r0,r1              ;348
                  |L15.98|
000062  6268              STR      r0,[r5,#0x24]         ;346
                  |L15.100|
000064  9908              LDR      r1,[sp,#0x20]         ;352
000066  9807              LDR      r0,[sp,#0x1c]         ;352
000068  4308              ORRS     r0,r0,r1              ;352
00006a  990e              LDR      r1,[sp,#0x38]         ;352
00006c  4308              ORRS     r0,r0,r1              ;352
00006e  60e8              STR      r0,[r5,#0xc]          ;352
000070  b009              ADD      sp,sp,#0x24
000072  bdf0              POP      {r4-r7,pc}
;;;354    
                          ENDP

                  |L15.116|
                          DCD      ||.constdata||+0x10
                  |L15.120|
                          DCD      0x50000200
                  |L15.124|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;365     */
;;;366    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;367    {
;;;368        /* Set time-out interrupt comparator */
;;;369        uart->TOR = (uart->TOR & ~UART_TOR_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;370    
;;;371        /* Set time-out counter enable */
;;;372        uart->IER |= UART_IER_TIME_OUT_EN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  2201              MOVS     r2,#1
00000e  02d2              LSLS     r2,r2,#11
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;373    }
000014  4770              BX       lr
;;;374    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;491     */
;;;492    uint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;493    {
000002  4604              MOV      r4,r0
;;;494        uint32_t  u32Count, u32delayno;
;;;495    
;;;496        for(u32Count = 0; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;497        {
;;;498            u32delayno = 0;
;;;499            while((uart->FSR & UART_FSR_TE_FLAG_Msk) == 0)   /* Wait Tx empty and Time-out manner */
;;;500            {
;;;501                u32delayno++;
;;;502                if(u32delayno >= 0x40000000)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L17.38|
                  |L17.12|
00000c  2300              MOVS     r3,#0                 ;498
00000e  e004              B        |L17.26|
                  |L17.16|
000010  1c5b              ADDS     r3,r3,#1              ;499
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L17.26|
;;;503                    return FALSE;
000016  2000              MOVS     r0,#0
;;;504            }
;;;505            uart->THR = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;506        }
;;;507    
;;;508        return u32Count;
;;;509    
;;;510    }
000018  bd70              POP      {r4-r6,pc}
                  |L17.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;499
00001c  00f6              LSLS     r6,r6,#3              ;499
00001e  d5f7              BPL      |L17.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;505
000022  6023              STR      r3,[r4,#0]            ;505
000024  1c40              ADDS     r0,r0,#1              ;505
                  |L17.38|
000026  4290              CMP      r0,r2                 ;496
000028  d1f0              BNE      |L17.12|
00002a  bd70              POP      {r4-r6,pc}
;;;511    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x01518000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 132
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
