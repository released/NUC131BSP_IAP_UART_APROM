; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC131\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\AP -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.DEBUG_UART_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  DEBUG_UART_Init PROC
;;;519    
;;;520    void DEBUG_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;521    {
;;;522        SYS_ResetModule(UART1_RST);
000002  4815              LDR      r0,|L1.88|
000004  f7fffffe          BL       SYS_ResetModule
;;;523    
;;;524        /* Configure UART0 and set UART0 baud rate */
;;;525        UART_Open(DEBUG_UART_PORT, 115200);
000008  4c14              LDR      r4,|L1.92|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;526        UART_EnableInt(DEBUG_UART_PORT, UART_IER_RDA_IEN_Msk | UART_IER_TOUT_IEN_Msk);
000014  2111              MOVS     r1,#0x11
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_EnableInt
00001c  2001              MOVS     r0,#1
00001e  4910              LDR      r1,|L1.96|
000020  0340              LSLS     r0,r0,#13
000022  6008              STR      r0,[r1,#0]
;;;527        NVIC_EnableIRQ(DEBUG_UART_PORT_IRQn);
;;;528    	
;;;529    	#if (_debug_log_UART_ == 1)	//debug
;;;530    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetHXTFreq());
000024  f7fffffe          BL       CLK_GetHXTFreq
000028  4601              MOV      r1,r0
00002a  a00e              ADR      r0,|L1.100|
00002c  f7fffffe          BL       __2printf
;;;531    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHCLKFreq());
000030  f7fffffe          BL       CLK_GetHCLKFreq
000034  4601              MOV      r1,r0
000036  a012              ADR      r0,|L1.128|
000038  f7fffffe          BL       __2printf
;;;532    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetPCLKFreq());	
00003c  f7fffffe          BL       CLK_GetPCLKFreq
000040  4601              MOV      r1,r0
000042  a015              ADR      r0,|L1.152|
000044  f7fffffe          BL       __2printf
;;;533    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetCPUFreq());
000048  f7fffffe          BL       CLK_GetCPUFreq
00004c  4601              MOV      r1,r0
00004e  a018              ADR      r0,|L1.176|
000050  f7fffffe          BL       __2printf
;;;534    
;;;535    	#endif
;;;536    }
000054  bd10              POP      {r4,pc}
;;;537    
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x04000011
                  |L1.92|
                          DCD      0x40150000
                  |L1.96|
                          DCD      0xe000e100
                  |L1.100|
000064  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000068  4b5f4765
00006c  74435055
000070  46726571
000074  203a2025
000078  38640d0a
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L1.128|
000080  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000084  47657448
000088  58544672
00008c  6571203a
000090  20253864
000094  0d0a00  
000097  00                DCB      0
                  |L1.152|
000098  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
00009c  4765744c
0000a0  58544672
0000a4  6571203a
0000a8  20253864
0000ac  0d0a00  
0000af  00                DCB      0
                  |L1.176|
0000b0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000b4  47657450
0000b8  434c4b30
0000bc  46726571
0000c0  203a2025
0000c4  38640d0a
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.FMC_SetVectorPageAddr||, CODE, READONLY, ALIGN=2

                  FMC_SetVectorPageAddr PROC
;;;427     */
;;;428    static __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
000000  4905              LDR      r1,|L2.24|
;;;429    {
;;;430        FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
000002  222e              MOVS     r2,#0x2e
000004  60ca              STR      r2,[r1,#0xc]
;;;431        FMC->ISPADR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
000006  6048              STR      r0,[r1,#4]
;;;432        FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
000008  2001              MOVS     r0,#1
00000a  6108              STR      r0,[r1,#0x10]
;;;433        __ISB();                         /* To make sure ISP/CPU be Synchronized */
00000c  f3bf8f6f          ISB      
                  |L2.16|
;;;434        while(FMC->ISPTRG);              /* Waiting for ISP Done */
000010  6908              LDR      r0,[r1,#0x10]
000012  2800              CMP      r0,#0
000014  d1fc              BNE      |L2.16|
;;;435    }
000016  4770              BX       lr
;;;436    
                          ENDP

                  |L2.24|
                          DCD      0x5000c000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;298    
;;;299    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;300    {
;;;301        SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB14_Msk | SYS_GPB_MFP_PB14_Msk);
000002  2005              MOVS     r0,#5
000004  0700              LSLS     r0,r0,#28
000006  6b42              LDR      r2,[r0,#0x34]
000008  2101              MOVS     r1,#1
00000a  0389              LSLS     r1,r1,#14
00000c  438a              BICS     r2,r2,r1
00000e  6342              STR      r2,[r0,#0x34]
;;;302        SYS->GPB_MFP |= (SYS_GPB_MFP_PB14_GPIO | SYS_GPB_MFP_PB15_GPIO);
000010  6b42              LDR      r2,[r0,#0x34]
000012  6342              STR      r2,[r0,#0x34]
;;;303    
;;;304    	
;;;305        GPIO_SetMode(PB, BIT14, GPIO_PMD_OUTPUT);
000014  4c05              LDR      r4,|L3.44|
000016  2201              MOVS     r2,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       GPIO_SetMode
;;;306        GPIO_SetMode(PB, BIT15, GPIO_PMD_OUTPUT);	
00001e  2201              MOVS     r2,#1
000020  03d1              LSLS     r1,r2,#15
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GPIO_SetMode
;;;307    }
000028  bd10              POP      {r4,pc}
;;;308    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x50004040

                          AREA ||i.IAPSystemReboot_RST||, CODE, READONLY, ALIGN=2

                  IAPSystemReboot_RST PROC
;;;239    
;;;240    void IAPSystemReboot_RST(unsigned char addr , unsigned char sel)
000000  b5f8              PUSH     {r3-r7,lr}
;;;241    {
;;;242        while(!UART_IS_TX_EMPTY(UART1));
000002  4a17              LDR      r2,|L4.96|
000004  460c              MOV      r4,r1                 ;241
000006  4605              MOV      r5,r0                 ;241
                  |L4.8|
000008  6993              LDR      r3,[r2,#0x18]
00000a  00d8              LSLS     r0,r3,#3
00000c  d5fc              BPL      |L4.8|
;;;243            
;;;244        /* Unlock protected registers */
;;;245        SYS_UnlockReg();
00000e  f7fffffe          BL       SYS_UnlockReg
;;;246        /* Enable FMC ISP function */
;;;247        FMC_Open();
000012  f7fffffe          BL       FMC_Open
;;;248    
;;;249        switch(addr) // CONFIG: w/ IAP
;;;250        {
;;;251            case RST_ADDR_LDROM:
;;;252                /* Mask all interrupt before changing VECMAP to avoid wrong interrupt handler fetched */
;;;253                __set_PRIMASK(1);    
;;;254                FMC_SetVectorPageAddr(FMC_APROM_BASE);
;;;255                FMC_SET_APROM_BOOT();        
000016  4e13              LDR      r6,|L4.100|
000018  2702              MOVS     r7,#2
00001a  2d00              CMP      r5,#0                 ;249
00001c  d002              BEQ      |L4.36|
00001e  2d01              CMP      r5,#1                 ;249
000020  d10f              BNE      |L4.66|
000022  e004              B        |L4.46|
                  |L4.36|
000024  2001              MOVS     r0,#1                 ;253
000026  f3808810          MSR      PRIMASK,r0            ;253
00002a  2000              MOVS     r0,#0                 ;254
;;;256                break;
00002c  e004              B        |L4.56|
                  |L4.46|
;;;257            case RST_ADDR_APROM:
;;;258                /* Mask all interrupt before changing VECMAP to avoid wrong interrupt handler fetched */
;;;259                __set_PRIMASK(1);    
00002e  2001              MOVS     r0,#1
000030  f3808810          MSR      PRIMASK,r0
;;;260                FMC_SetVectorPageAddr(APROM_APPLICATION_START);
000034  2003              MOVS     r0,#3
000036  0300              LSLS     r0,r0,#12
                  |L4.56|
000038  f7fffffe          BL       FMC_SetVectorPageAddr
00003c  6830              LDR      r0,[r6,#0]            ;255
00003e  43b8              BICS     r0,r0,r7              ;255
000040  6030              STR      r0,[r6,#0]            ;255
                  |L4.66|
;;;261                FMC_SET_APROM_BOOT();        
;;;262                break;            
;;;263        }
;;;264    
;;;265        switch(sel)
000042  2c00              CMP      r4,#0
000044  d006              BEQ      |L4.84|
000046  2c01              CMP      r4,#1
000048  d006              BEQ      |L4.88|
00004a  2c02              CMP      r4,#2
00004c  d101              BNE      |L4.82|
;;;266        {
;;;267            case RST_SEL_NVIC:  // Reset I/O and peripherals , only check BS(FMC_ISPCTL[1])
;;;268                NVIC_SystemReset();
;;;269                break;
;;;270            case RST_SEL_CPU:   // Not reset I/O and peripherals
;;;271                SYS_ResetCPU();
;;;272                break;   
;;;273            case RST_SEL_CHIP:
;;;274                SYS_ResetChip();// Reset I/O and peripherals ,  BS(FMC_ISPCTL[1]) reload from CONFIG setting (CBS)
00004e  f7fffffe          BL       SYS_ResetChip
                  |L4.82|
;;;275                break;                       
;;;276        } 
;;;277    }
000052  bdf8              POP      {r3-r7,pc}
                  |L4.84|
000054  f7fffffe          BL       NVIC_SystemReset
                  |L4.88|
000058  f7fffffe          BL       SYS_ResetCPU
00005c  bdf8              POP      {r3-r7,pc}
;;;278    
                          ENDP

00005e  0000              DCW      0x0000
                  |L4.96|
                          DCD      0x40150000
                  |L4.100|
                          DCD      0x5000c000

                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;606     */
;;;607    __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;608    {
;;;609      __DSB();                                                     /* Ensure all outstanding memory accesses included
;;;610                                                                      buffered write are completed before reset */
;;;611      SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
000004  4903              LDR      r1,|L5.20|
000006  4802              LDR      r0,|L5.16|
000008  60c8              STR      r0,[r1,#0xc]
;;;612                     SCB_AIRCR_SYSRESETREQ_Msk);
;;;613      __DSB();                                                     /* Ensure completion of memory access */
00000a  f3bf8f4f          DSB      
                  |L5.14|
;;;614      while(1);                                                    /* wait until reset */
00000e  e7fe              B        |L5.14|
;;;615    }
;;;616    
                          ENDP

                  |L5.16|
                          DCD      0x05fa0004
                  |L5.20|
                          DCD      0xe000ed00

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;537    
;;;538    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;539    {
;;;540        /* Unlock protected registers */
;;;541        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;542    
;;;543        CLK_EnableXtalRC(CLK_PWRCON_OSC22M_EN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;544        CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;545    
;;;546    //    CLK_EnableXtalRC(CLK_PWRCON_XTL12M_EN_Msk);
;;;547    //    CLK_WaitClockReady(CLK_CLKSTATUS_XTL12M_STB_Msk);
;;;548    
;;;549        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;550        CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_HIRC, CLK_CLKDIV_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;551    
;;;552        CLK_SetCoreClock(PLL_CLOCK);
00001a  4818              LDR      r0,|L6.124|
00001c  f7fffffe          BL       CLK_SetCoreClock
;;;553    
;;;554        // CLK_EnableModuleClock(UART0_MODULE);
;;;555        // CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART_S_HIRC, CLK_CLKDIV_UART(1));
;;;556    
;;;557        CLK_EnableModuleClock(UART1_MODULE);
000020  4c17              LDR      r4,|L6.128|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       CLK_EnableModuleClock
;;;558        CLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART_S_HIRC, CLK_CLKDIV_UART(1));
000028  2103              MOVS     r1,#3
00002a  2200              MOVS     r2,#0
00002c  0609              LSLS     r1,r1,#24
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       CLK_SetModuleClock
;;;559    
;;;560        CLK_EnableModuleClock(TMR0_MODULE);
000034  4c13              LDR      r4,|L6.132|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       CLK_EnableModuleClock
;;;561      	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0_S_HIRC, 0);
00003c  2107              MOVS     r1,#7
00003e  2200              MOVS     r2,#0
000040  0209              LSLS     r1,r1,#8
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       CLK_SetModuleClock
;;;562    
;;;563        CLK_EnableModuleClock(TMR1_MODULE);
000048  4c0f              LDR      r4,|L6.136|
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       CLK_EnableModuleClock
;;;564      	CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1_S_HIRC, 0);
000050  2107              MOVS     r1,#7
000052  2200              MOVS     r2,#0
000054  0309              LSLS     r1,r1,#12
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       CLK_SetModuleClock
;;;565    
;;;566        // UART 0 for ISP 
;;;567        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;568        // SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB0_Msk | SYS_GPB_MFP_PB1_Msk);
;;;569        // SYS->GPB_MFP |= (SYS_GPB_MFP_PB0_UART0_RXD | SYS_GPB_MFP_PB1_UART0_TXD);
;;;570    
;;;571    	// UART 1 for debug
;;;572        SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB4_Msk | SYS_GPB_MFP_PB5_Msk);
00005c  2005              MOVS     r0,#5
00005e  0700              LSLS     r0,r0,#28
000060  6b42              LDR      r2,[r0,#0x34]
000062  2130              MOVS     r1,#0x30
000064  438a              BICS     r2,r2,r1
000066  6342              STR      r2,[r0,#0x34]
;;;573        SYS->GPB_MFP |= (SYS_GPB_MFP_PB4_UART1_RXD | SYS_GPB_MFP_PB5_UART1_TXD);
000068  6b42              LDR      r2,[r0,#0x34]
00006a  430a              ORRS     r2,r2,r1
00006c  6342              STR      r2,[r0,#0x34]
;;;574    
;;;575       /* Update System Core Clock */
;;;576        SystemCoreClockUpdate();
00006e  f7fffffe          BL       SystemCoreClockUpdate
000072  4906              LDR      r1,|L6.140|
000074  2000              MOVS     r0,#0
000076  6008              STR      r0,[r1,#0]
;;;577    
;;;578        /* Lock protected registers */
;;;579        SYS_LockReg();
;;;580    }
000078  bd10              POP      {r4,pc}
;;;581    
                          ENDP

00007a  0000              DCW      0x0000
                  |L6.124|
                          DCD      0x02faf080
                  |L6.128|
                          DCD      0x57803d11
                  |L6.132|
                          DCD      0x5e800002
                  |L6.136|
                          DCD      0x5ec00003
                  |L6.140|
                          DCD      0x50000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1844     */
;;;1845   static __INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1846   {
;;;1847       while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
;;;1848       {
;;;1849           SYS->REGWRPROT = 0x59;
000002  2159              MOVS     r1,#0x59
;;;1850           SYS->REGWRPROT = 0x16;
000004  2316              MOVS     r3,#0x16
000006  4805              LDR      r0,|L7.28|
;;;1851           SYS->REGWRPROT = 0x88;
000008  2288              MOVS     r2,#0x88
00000a  e002              B        |L7.18|
                  |L7.12|
00000c  6001              STR      r1,[r0,#0]            ;1849
00000e  6003              STR      r3,[r0,#0]            ;1850
000010  6002              STR      r2,[r0,#0]
                  |L7.18|
000012  6804              LDR      r4,[r0,#0]            ;1847
000014  2c01              CMP      r4,#1                 ;1847
000016  d1f9              BNE      |L7.12|
;;;1852       }
;;;1853   }
000018  bd10              POP      {r4,pc}
;;;1854   
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x50000100

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  SysTick_Handler PROC
;;;396    
;;;397    void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;398    {
;;;399    	static uint32_t LOG = 0;   
;;;400    
;;;401        systick_counter();
000002  f7fffffe          BL       systick_counter
000006  4c0a              LDR      r4,|L8.48|
000008  68a0              LDR      r0,[r4,#8]  ; counter_systick
00000a  1c40              ADDS     r0,r0,#1
;;;402        if (get_systick() >= 0xFFFFFFFF)
00000c  d100              BNE      |L8.16|
00000e  60a0              STR      r0,[r4,#8]  ; counter_systick
                  |L8.16|
000010  68a0              LDR      r0,[r4,#8]  ; counter_systick
;;;403        {
;;;404          set_systick(0);      
;;;405        }
;;;406    
;;;407        if ((get_systick() % 1000) == 0)
000012  217d              MOVS     r1,#0x7d
000014  00c9              LSLS     r1,r1,#3
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  2900              CMP      r1,#0
00001c  d106              BNE      |L8.44|
;;;408        {
;;;409            printf("%s : %4d\r\n",__FUNCTION__,LOG++);
00001e  68e2              LDR      r2,[r4,#0xc]  ; LOG
000020  4904              LDR      r1,|L8.52|
000022  1c50              ADDS     r0,r2,#1
000024  60e0              STR      r0,[r4,#0xc]  ; LOG
000026  a004              ADR      r0,|L8.56|
000028  f7fffffe          BL       __2printf
                  |L8.44|
;;;410        }
;;;411    
;;;412        #if defined (ENABLE_TICK_EVENT)
;;;413        TickCheckTickEvent();
;;;414        #endif    
;;;415    }
00002c  bd10              POP      {r4,pc}
;;;416    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      ||.data||
                  |L8.52|
                          DCD      ||.constdata||+0xf
                  |L8.56|
000038  2573203a          DCB      "%s : %4d\r\n",0
00003c  20253464
000040  0d0a00  
000043  00                DCB      0

                          AREA ||i.SystemReboot_RST||, CODE, READONLY, ALIGN=2

                  SystemReboot_RST PROC
;;;199    
;;;200    void SystemReboot_RST(unsigned char addr , unsigned char sel)
000000  b5f8              PUSH     {r3-r7,lr}
;;;201    {
;;;202        while(!UART_IS_TX_EMPTY(UART1));
000002  4a18              LDR      r2,|L9.100|
000004  460c              MOV      r4,r1                 ;201
000006  4605              MOV      r5,r0                 ;201
                  |L9.8|
000008  6993              LDR      r3,[r2,#0x18]
00000a  00d8              LSLS     r0,r3,#3
00000c  d5fc              BPL      |L9.8|
;;;203            
;;;204        /* Unlock protected registers */
;;;205        SYS_UnlockReg();
00000e  f7fffffe          BL       SYS_UnlockReg
;;;206        /* Enable FMC ISP function */
;;;207        FMC_Open();
000012  f7fffffe          BL       FMC_Open
;;;208    
;;;209        switch(addr) // CONFIG: w/ IAP
;;;210        {
;;;211            case RST_ADDR_LDROM:
;;;212                /* Mask all interrupt before changing VECMAP to avoid wrong interrupt handler fetched */
;;;213                __set_PRIMASK(1);    
;;;214                FMC_SetVectorPageAddr(FMC_LDROM_BASE);
;;;215                FMC_SET_LDROM_BOOT();        
000016  4e14              LDR      r6,|L9.104|
000018  2702              MOVS     r7,#2
00001a  2d00              CMP      r5,#0                 ;209
00001c  d002              BEQ      |L9.36|
00001e  2d01              CMP      r5,#1                 ;209
000020  d112              BNE      |L9.72|
000022  e008              B        |L9.54|
                  |L9.36|
000024  2001              MOVS     r0,#1                 ;213
000026  f3808810          MSR      PRIMASK,r0            ;213
00002a  0500              LSLS     r0,r0,#20             ;214
00002c  f7fffffe          BL       FMC_SetVectorPageAddr
000030  6830              LDR      r0,[r6,#0]
000032  4338              ORRS     r0,r0,r7
;;;216                break;
000034  e007              B        |L9.70|
                  |L9.54|
;;;217            case RST_ADDR_APROM:
;;;218                /* Mask all interrupt before changing VECMAP to avoid wrong interrupt handler fetched */
;;;219                __set_PRIMASK(1);    
000036  2001              MOVS     r0,#1
000038  f3808810          MSR      PRIMASK,r0
;;;220                FMC_SetVectorPageAddr(FMC_APROM_BASE);
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       FMC_SetVectorPageAddr
;;;221                FMC_SET_APROM_BOOT();        
000042  6830              LDR      r0,[r6,#0]
000044  43b8              BICS     r0,r0,r7
                  |L9.70|
000046  6030              STR      r0,[r6,#0]            ;215
                  |L9.72|
;;;222                break;            
;;;223        }
;;;224    
;;;225        switch(sel)
000048  2c00              CMP      r4,#0
00004a  d006              BEQ      |L9.90|
00004c  2c01              CMP      r4,#1
00004e  d006              BEQ      |L9.94|
000050  2c02              CMP      r4,#2
000052  d101              BNE      |L9.88|
;;;226        {
;;;227            case RST_SEL_NVIC:  // Reset I/O and peripherals , only check BS(FMC_ISPCTL[1])
;;;228                NVIC_SystemReset();
;;;229                break;
;;;230            case RST_SEL_CPU:   // Not reset I/O and peripherals
;;;231                SYS_ResetCPU();
;;;232                break;   
;;;233            case RST_SEL_CHIP:
;;;234                SYS_ResetChip();// Reset I/O and peripherals ,  BS(FMC_ISPCTL[1]) reload from CONFIG setting (CBS)
000054  f7fffffe          BL       SYS_ResetChip
                  |L9.88|
;;;235                break;                       
;;;236        } 
;;;237    }
000058  bdf8              POP      {r3-r7,pc}
                  |L9.90|
00005a  f7fffffe          BL       NVIC_SystemReset
                  |L9.94|
00005e  f7fffffe          BL       SYS_ResetCPU
000062  bdf8              POP      {r3-r7,pc}
;;;238    
                          ENDP

                  |L9.100|
                          DCD      0x40150000
                  |L9.104|
                          DCD      0x5000c000

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;464    
;;;465    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;466    {
;;;467        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L10.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1508              ASRS     r0,r1,#20
00001c  4904              LDR      r1,|L10.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;468        TIMER_EnableInt(TIMER1);
;;;469        NVIC_EnableIRQ(TMR1_IRQn);	
;;;470        TIMER_Start(TIMER1);
;;;471    }
000028  bd10              POP      {r4,pc}
;;;472    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0x40010020
                  |L10.48|
                          DCD      0xe000e100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR1_IRQHandler PROC
;;;431    
;;;432    void TMR1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
000002  480f              LDR      r0,|L11.64|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;433    {
00000a  d017              BEQ      |L11.60|
00000c  2501              MOVS     r5,#1
00000e  6085              STR      r5,[r0,#8]
;;;434    	static uint32_t LOG = 0;
;;;435    	
;;;436        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;437        {
;;;438            TIMER_ClearIntFlag(TIMER1);
;;;439    		tick_counter();
000010  f7fffffe          BL       tick_counter
000014  4c0b              LDR      r4,|L11.68|
000016  6860              LDR      r0,[r4,#4]  ; counter_tick
;;;440    
;;;441    		#if defined (APROM_1)
;;;442    		if ((get_tick() % 1000) == 0)
;;;443    		{
;;;444            	printf("1)%s : %4d\r\n",__FUNCTION__,LOG++);
;;;445    			PB14 ^= 1;
;;;446    		}
;;;447    		#endif
;;;448    
;;;449    		#if defined (APROM_2)
;;;450    		if ((get_tick() % 500) == 0)
000018  21ff              MOVS     r1,#0xff
00001a  31f5              ADDS     r1,r1,#0xf5
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  2900              CMP      r1,#0
000022  d10a              BNE      |L11.58|
;;;451    		{
;;;452            	printf("2)%s : %4d\r\n",__FUNCTION__,LOG++);
000024  6922              LDR      r2,[r4,#0x10]  ; LOG
000026  4908              LDR      r1,|L11.72|
000028  1c50              ADDS     r0,r2,#1
00002a  6120              STR      r0,[r4,#0x10]  ; LOG
00002c  a007              ADR      r0,|L11.76|
00002e  f7fffffe          BL       __2printf
;;;453    			PB14 ^= 1;
000032  480a              LDR      r0,|L11.92|
000034  6b81              LDR      r1,[r0,#0x38]
000036  4069              EORS     r1,r1,r5
000038  6381              STR      r1,[r0,#0x38]
                  |L11.58|
00003a  6860              LDR      r0,[r4,#4]  ; counter_tick
                  |L11.60|
;;;454    		}
;;;455    		#endif
;;;456    
;;;457    		if ((get_tick() % 50) == 0)
;;;458    		{
;;;459    
;;;460    		}	
;;;461        }
;;;462    }
00003c  bd70              POP      {r4-r6,pc}
;;;463    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      0x40010020
                  |L11.68|
                          DCD      ||.data||
                  |L11.72|
                          DCD      ||.constdata||+0x1f
                  |L11.76|
00004c  32292573          DCB      "2)%s : %4d\r\n",0
000050  203a2025
000054  34640d0a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L11.92|
                          DCD      0x50004240

                          AREA ||i.UART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART1_IRQHandler PROC
;;;503    
;;;504    void DEBUG_UART_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;505    {
;;;506        if(UART_GET_INT_FLAG(DEBUG_UART_PORT, UART_ISR_RDA_INT_Msk | UART_ISR_TOUT_IF_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L12.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  21ff              MOVS     r1,#0xff
000008  3111              ADDS     r1,r1,#0x11
00000a  4208              TST      r0,r1
00000c  d102              BNE      |L12.20|
00000e  e004              B        |L12.26|
                  |L12.16|
;;;507        {
;;;508            while(UART_GET_RX_EMPTY(DEBUG_UART_PORT) == 0)
;;;509            {
;;;510    			UARTx_Process();
000010  f7fffffe          BL       UARTx_Process
                  |L12.20|
000014  69a1              LDR      r1,[r4,#0x18]         ;508
000016  0449              LSLS     r1,r1,#17             ;508
000018  d5fa              BPL      |L12.16|
                  |L12.26|
;;;511            }
;;;512        }
;;;513    
;;;514        if(DEBUG_UART_PORT->FSR & (UART_FSR_BIF_Msk | UART_FSR_FEF_Msk | UART_FSR_PEF_Msk | UART_FSR_RX_OVER_IF_Msk))
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4620              MOV      r0,r4
00001e  2271              MOVS     r2,#0x71
000020  4211              TST      r1,r2
000022  d003              BEQ      |L12.44|
;;;515        {
;;;516            UART_ClearIntFlag(DEBUG_UART_PORT, (UART_ISR_RLS_INT_Msk| UART_ISR_BUF_ERR_INT_Msk));
000024  2109              MOVS     r1,#9
000026  0289              LSLS     r1,r1,#10
000028  f7fffffe          BL       UART_ClearIntFlag
                  |L12.44|
;;;517        }	
;;;518    }
00002c  bd10              POP      {r4,pc}
;;;519    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40150000

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;472    
;;;473    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;474    {
;;;475    	uint8_t res = 0;
;;;476    	res = UART_READ(DEBUG_UART_PORT);
000002  4812              LDR      r0,|L13.76|
000004  6800              LDR      r0,[r0,#0]
000006  b2c0              UXTB     r0,r0
;;;477    
;;;478    	if (res > 0x7F)
000008  287f              CMP      r0,#0x7f
00000a  d903              BLS      |L13.20|
;;;479    	{
;;;480    		printf("invalid command\r\n");
00000c  a010              ADR      r0,|L13.80|
00000e  f7fffffe          BL       __2printf
                  |L13.18|
;;;481    	}
;;;482    	else
;;;483    	{
;;;484    		switch(res)
;;;485    		{
;;;486    			case '1':
;;;487    				break;
;;;488    
;;;489    			case 'X':
;;;490    			case 'x':
;;;491    			case 'Z':
;;;492    			case 'z':
;;;493        			read_magic_tag();			
;;;494    	            write_magic_tag(0xA5);
;;;495        			read_magic_tag();
;;;496    
;;;497    	            printf("Perform RST to enter BOOTLOADER\r\n");
;;;498    	            IAPSystemReboot_RST(RST_ADDR_LDROM,RST_SEL_CPU);	
;;;499    				break;
;;;500    		}
;;;501    	}
;;;502    }
000012  bd10              POP      {r4,pc}
                  |L13.20|
000014  285a              CMP      r0,#0x5a              ;484
000016  d009              BEQ      |L13.44|
000018  dc04              BGT      |L13.36|
00001a  2831              CMP      r0,#0x31              ;484
00001c  d0f9              BEQ      |L13.18|
00001e  2858              CMP      r0,#0x58              ;484
000020  d1f7              BNE      |L13.18|
000022  e003              B        |L13.44|
                  |L13.36|
000024  2878              CMP      r0,#0x78              ;484
000026  d001              BEQ      |L13.44|
000028  287a              CMP      r0,#0x7a              ;484
00002a  d1f2              BNE      |L13.18|
                  |L13.44|
00002c  f7fffffe          BL       read_magic_tag
000030  20a5              MOVS     r0,#0xa5              ;494
000032  f7fffffe          BL       write_magic_tag
000036  f7fffffe          BL       read_magic_tag
00003a  a00a              ADR      r0,|L13.100|
00003c  f7fffffe          BL       __2printf
000040  2101              MOVS     r1,#1                 ;498
000042  2000              MOVS     r0,#0                 ;498
000044  f7fffffe          BL       IAPSystemReboot_RST
000048  bd10              POP      {r4,pc}
;;;503    
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      0x40150000
                  |L13.80|
000050  696e7661          DCB      "invalid command\r\n",0
000054  6c696420
000058  636f6d6d
00005c  616e640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0
                  |L13.100|
000064  50657266          DCB      "Perform RST to enter BOOTLOADER\r\n",0
000068  6f726d20
00006c  52535420
000070  746f2065
000074  6e746572
000078  20424f4f
00007c  544c4f41
000080  4445520d
000084  0a00    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;95     
;;;96     void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;97     {
;;;98         uint16_t i = 0;	
000002  2400              MOVS     r4,#0
000004  4617              MOV      r7,r2                 ;97
;;;99     	
;;;100        for (i = 0; i < nBytes; i++)
;;;101        {
;;;102            if (src[i] != des[i])
;;;103            {
;;;104                printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;105    			set_flag(flag_error , ENABLE);
000006  2602              MOVS     r6,#2
000008  4d0e              LDR      r5,|L14.68|
00000a  e00e              B        |L14.42|
                  |L14.12|
00000c  9800              LDR      r0,[sp,#0]            ;102
00000e  5d02              LDRB     r2,[r0,r4]            ;102
000010  9801              LDR      r0,[sp,#4]            ;102
000012  5d03              LDRB     r3,[r0,r4]            ;102
000014  429a              CMP      r2,r3                 ;102
000016  d006              BEQ      |L14.38|
000018  4621              MOV      r1,r4                 ;104
00001a  a00b              ADR      r0,|L14.72|
00001c  f7fffffe          BL       __2printf
000020  6828              LDR      r0,[r5,#0]  ; BitFlag
000022  4330              ORRS     r0,r0,r6
000024  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L14.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;100
                  |L14.42|
00002a  42bc              CMP      r4,r7                 ;100
00002c  dbee              BLT      |L14.12|
;;;106            }
;;;107        }
;;;108    
;;;109    	if (!is_flag_set(flag_error))
00002e  6828              LDR      r0,[r5,#0]  ; BitFlag
000030  0780              LSLS     r0,r0,#30
000032  d406              BMI      |L14.66|
;;;110    	{
;;;111        	printf("%s finish \r\n" , __FUNCTION__);	
000034  490d              LDR      r1,|L14.108|
000036  a00e              ADR      r0,|L14.112|
000038  f7fffffe          BL       __2printf
;;;112    		set_flag(flag_error , DISABLE);
00003c  6828              LDR      r0,[r5,#0]  ; BitFlag
00003e  43b0              BICS     r0,r0,r6
000040  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L14.66|
;;;113    	}
;;;114    
;;;115    }
000042  bdfe              POP      {r1-r7,pc}
;;;116    
                          ENDP

                  |L14.68|
                          DCD      ||.data||
                  |L14.72|
000048  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
00004c  72206964
000050  78203a20
000054  25346420
000058  3a203078
00005c  25325820
000060  2c203078
000064  2532580d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L14.108|
                          DCD      ||.constdata||
                  |L14.112|
000070  25732066          DCB      "%s finish \r\n",0
000074  696e6973
000078  68200d0a
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;132    
;;;133    void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135        uint8_t *pu8Src, *pu8Dest;
;;;136        unsigned int i;
;;;137        
;;;138        pu8Dest = (uint8_t *)dest;
;;;139        pu8Src  = (uint8_t *)src;
;;;140    
;;;141    
;;;142    	#if 0
;;;143    	  while (size--)
;;;144    	    *pu8Dest++ = *pu8Src++;
;;;145    	#else
;;;146        for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L15.12|
                  |L15.6|
;;;147            pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L15.12|
00000c  4293              CMP      r3,r2                 ;146
00000e  d3fa              BCC      |L15.6|
;;;148    	#endif
;;;149    }
000010  bd10              POP      {r4,pc}
;;;150    
                          ENDP


                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;193    
;;;194    void delay_ms(uint16_t ms)
000000  217d              MOVS     r1,#0x7d
;;;195    {
;;;196    	TIMER_Delay(TIMER0, 1000*ms);
000002  00c9              LSLS     r1,r1,#3
000004  b510              PUSH     {r4,lr}               ;195
000006  4341              MULS     r1,r0,r1
000008  4801              LDR      r0,|L16.16|
00000a  f7fffffe          BL       TIMER_Delay
;;;197    }
00000e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L16.16|
                          DCD      0x40010000

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;150    
;;;151    void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b5f8              PUSH     {r3-r7,lr}
;;;152    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;153        uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;154        
;;;155        printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L17.56|
00000a  f7fffffe          BL       __2printf
;;;156        for (i = 0 ; i < nBytes ; i++)
;;;157        {
;;;158            printf("0x%2X," , pucBuff[i]);
;;;159            if ((i+1)%8 ==0)
00000e  2701              MOVS     r7,#1
000010  077f              LSLS     r7,r7,#29
000012  e00b              B        |L17.44|
                  |L17.20|
000014  5d31              LDRB     r1,[r6,r4]            ;158
000016  a00d              ADR      r0,|L17.76|
000018  f7fffffe          BL       __2printf
00001c  0760              LSLS     r0,r4,#29
00001e  42f8              CMN      r0,r7
000020  d102              BNE      |L17.40|
;;;160            {
;;;161                printf("\r\n");
000022  a00c              ADR      r0,|L17.84|
000024  f7fffffe          BL       __2printf
                  |L17.40|
000028  1c64              ADDS     r4,r4,#1
00002a  b2a4              UXTH     r4,r4                 ;156
                  |L17.44|
00002c  42ac              CMP      r4,r5                 ;156
00002e  dbf1              BLT      |L17.20|
;;;162            }            
;;;163        }
;;;164        printf("\r\n\r\n");
000030  a009              ADR      r0,|L17.88|
000032  f7fffffe          BL       __2printf
;;;165    }
000036  bdf8              POP      {r3-r7,pc}
;;;166    
                          ENDP

                  |L17.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L17.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L17.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L17.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;166    
;;;167    void dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  b5f8              PUSH     {r3-r7,lr}
;;;168    {
000002  460e              MOV      r6,r1
000004  4607              MOV      r7,r0
;;;169        int     nIdx, i;
;;;170    
;;;171        nIdx = 0;
000006  2500              MOVS     r5,#0
000008  e025              B        |L18.86|
                  |L18.10|
;;;172        while (nBytes > 0)
;;;173        {
;;;174            printf("0x%04X  ", nIdx);
00000a  4629              MOV      r1,r5
00000c  a015              ADR      r0,|L18.100|
00000e  f7fffffe          BL       __2printf
;;;175            for (i = 0; i < 16; i++)
000012  2400              MOVS     r4,#0
                  |L18.20|
;;;176                printf("%02X ", pucBuff[nIdx + i]);
000014  1928              ADDS     r0,r5,r4
000016  5c39              LDRB     r1,[r7,r0]
000018  a015              ADR      r0,|L18.112|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1
000020  2c10              CMP      r4,#0x10              ;175
000022  dbf7              BLT      |L18.20|
;;;177            printf("  ");
000024  a014              ADR      r0,|L18.120|
000026  f7fffffe          BL       __2printf
;;;178            for (i = 0; i < 16; i++)
00002a  2400              MOVS     r4,#0
                  |L18.44|
;;;179            {
;;;180                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002c  1928              ADDS     r0,r5,r4
00002e  5c39              LDRB     r1,[r7,r0]
000030  4608              MOV      r0,r1
000032  3820              SUBS     r0,r0,#0x20
000034  285f              CMP      r0,#0x5f
000036  d203              BCS      |L18.64|
;;;181                    printf("%c", pucBuff[nIdx + i]);
000038  a010              ADR      r0,|L18.124|
00003a  f7fffffe          BL       __2printf
00003e  e002              B        |L18.70|
                  |L18.64|
;;;182                else
;;;183                    printf(".");
000040  a00f              ADR      r0,|L18.128|
000042  f7fffffe          BL       __2printf
                  |L18.70|
000046  1c64              ADDS     r4,r4,#1
000048  1e76              SUBS     r6,r6,#1
00004a  2c10              CMP      r4,#0x10              ;178
00004c  dbee              BLT      |L18.44|
;;;184                nBytes--;
;;;185            }
;;;186            nIdx += 16;
;;;187            printf("\n");
00004e  a00d              ADR      r0,|L18.132|
000050  3510              ADDS     r5,r5,#0x10
000052  f7fffffe          BL       __2printf
                  |L18.86|
000056  2e00              CMP      r6,#0                 ;172
000058  dcd7              BGT      |L18.10|
;;;188        }
;;;189        printf("\n");
00005a  a00a              ADR      r0,|L18.132|
00005c  f7fffffe          BL       __2printf
;;;190    }
000060  bdf8              POP      {r3-r7,pc}
;;;191    
                          ENDP

000062  0000              DCW      0x0000
                  |L18.100|
000064  30782530          DCB      "0x%04X  ",0
000068  34582020
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L18.112|
000070  25303258          DCB      "%02X ",0
000074  2000    
000076  00                DCB      0
000077  00                DCB      0
                  |L18.120|
000078  202000            DCB      "  ",0
00007b  00                DCB      0
                  |L18.124|
00007c  256300            DCB      "%c",0
00007f  00                DCB      0
                  |L18.128|
000080  2e00              DCB      ".",0
000082  00                DCB      0
000083  00                DCB      0
                  |L18.132|
000084  0a00              DCB      "\n",0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.enable_sys_tick||, CODE, READONLY, ALIGN=2

                  enable_sys_tick PROC
;;;416    
;;;417    void enable_sys_tick(int ticks_per_second)
000000  b510              PUSH     {r4,lr}
000002  4b12              LDR      r3,|L19.76|
;;;418    {
;;;419        set_systick(0);
000004  2200              MOVS     r2,#0
000006  609a              STR      r2,[r3,#8]  ; counter_systick
;;;420        if (SysTick_Config(SystemCoreClock / ticks_per_second))
000008  4601              MOV      r1,r0
00000a  4811              LDR      r0,|L19.80|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  4910              LDR      r1,|L19.84|
000014  4288              CMP      r0,r1
000016  d901              BLS      |L19.28|
000018  2001              MOVS     r0,#1
00001a  e010              B        |L19.62|
                  |L19.28|
00001c  0201              LSLS     r1,r0,#8
00001e  0a09              LSRS     r1,r1,#8
000020  480d              LDR      r0,|L19.88|
000022  1e49              SUBS     r1,r1,#1
000024  6141              STR      r1,[r0,#0x14]
000026  490d              LDR      r1,|L19.92|
000028  2207              MOVS     r2,#7
00002a  69cb              LDR      r3,[r1,#0x1c]
00002c  021b              LSLS     r3,r3,#8
00002e  0a1b              LSRS     r3,r3,#8
000030  0444              LSLS     r4,r0,#17
000032  4323              ORRS     r3,r3,r4
000034  61cb              STR      r3,[r1,#0x1c]
000036  2100              MOVS     r1,#0
000038  6181              STR      r1,[r0,#0x18]
00003a  6102              STR      r2,[r0,#0x10]
00003c  4608              MOV      r0,r1
                  |L19.62|
00003e  2800              CMP      r0,#0
000040  d003              BEQ      |L19.74|
;;;421        {
;;;422            /* Setup SysTick Timer for 1 second interrupts  */
;;;423            printf("Set system tick error!!\n");
000042  a007              ADR      r0,|L19.96|
000044  f7fffffe          BL       __2printf
                  |L19.72|
;;;424            while (1);
000048  e7fe              B        |L19.72|
                  |L19.74|
;;;425        }
;;;426    
;;;427        #if defined (ENABLE_TICK_EVENT)
;;;428        TickInitTickEvent();
;;;429        #endif
;;;430    }
00004a  bd10              POP      {r4,pc}
;;;431    
                          ENDP

                  |L19.76|
                          DCD      ||.data||
                  |L19.80|
                          DCD      SystemCoreClock
                  |L19.84|
                          DCD      0x00ffffff
                  |L19.88|
                          DCD      0xe000e000
                  |L19.92|
                          DCD      0xe000ed04
                  |L19.96|
000060  53657420          DCB      "Set system tick error!!\n",0
000064  73797374
000068  656d2074
00006c  69636b20
000070  6572726f
000074  7221210a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.get_systick||, CODE, READONLY, ALIGN=2

                  get_systick PROC
;;;70     
;;;71     uint32_t get_systick(void)
000000  4801              LDR      r0,|L20.8|
;;;72     {
;;;73     	return (counter_systick);
000002  6880              LDR      r0,[r0,#8]  ; counter_systick
;;;74     }
000004  4770              BX       lr
;;;75     
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      ||.data||

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;85     
;;;86     uint32_t get_tick(void)
000000  4801              LDR      r0,|L21.8|
;;;87     {
;;;88     	return (counter_tick);
000002  6840              LDR      r0,[r0,#4]  ; counter_tick
;;;89     }
000004  4770              BX       lr
;;;90     
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;581    
;;;582    int main()
000000  f7fffffe          BL       SYS_Init
;;;583    {
;;;584        SYS_Init();
;;;585    
;;;586    	GPIO_Init();
000004  f7fffffe          BL       GPIO_Init
;;;587    	DEBUG_UART_Init();
000008  f7fffffe          BL       DEBUG_UART_Init
;;;588    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;589    
;;;590        read_magic_tag();// for debug
000010  f7fffffe          BL       read_magic_tag
                  |L22.20|
;;;591    
;;;592        #if defined (ENABLE_TICK_EVENT)
;;;593        enable_sys_tick(1000);
;;;594        TickSetTickEvent(1000, TickCallback_processA);  // 1000 ms
;;;595        TickSetTickEvent(5000, TickCallback_processB);  // 5000 ms
;;;596        #endif
;;;597    
;;;598        /* Got no where to go, just loop forever */
;;;599        while(1)
000014  e7fe              B        |L22.20|
;;;600        {
;;;601    
;;;602    
;;;603        }
;;;604    }
;;;605    
                          ENDP


                          AREA ||i.read_magic_tag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  read_magic_tag PROC
;;;279    
;;;280    uint8_t read_magic_tag(void)
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282        uint8_t tag = 0;
;;;283    
;;;284        tag = (uint8_t) flag_check_ISP_process;
000002  4804              LDR      r0,|L23.20|
000004  7804              LDRB     r4,[r0,#0]  ; flag_check_ISP_process
;;;285    
;;;286        printf("Read MagicTag <0x%02X>\r\n", tag);
000006  a004              ADR      r0,|L23.24|
000008  4621              MOV      r1,r4
00000a  f7fffffe          BL       __2printf
;;;287        
;;;288        return tag;
00000e  4620              MOV      r0,r4
;;;289    }
000010  bd10              POP      {r4,pc}
;;;290    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      ||.ARM.__AT_0x20001FFC||
                  |L23.24|
000018  52656164          DCB      "Read MagicTag <0x%02X>\r\n",0
00001c  204d6167
000020  69635461
000024  67203c30
000028  78253032
00002c  583e0d0a
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0

                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;116    
;;;117    void reset_buffer(void *dest, unsigned int val, unsigned int size)
000000  b2c9              UXTB     r1,r1
;;;118    {
000002  e001              B        |L24.8|
                  |L24.4|
;;;119        uint8_t *pu8Dest;
;;;120    //    unsigned int i;
;;;121        
;;;122        pu8Dest = (uint8_t *)dest;
;;;123    
;;;124    	#if 1
;;;125    	while (size-- > 0)
;;;126    		*pu8Dest++ = val;
000004  7001              STRB     r1,[r0,#0]
000006  1c40              ADDS     r0,r0,#1
                  |L24.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L24.4|
;;;127    	#else
;;;128    	memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
;;;129    	#endif
;;;130    	
;;;131    }
00000c  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||i.set_systick||, CODE, READONLY, ALIGN=2

                  set_systick PROC
;;;75     
;;;76     void set_systick(uint32_t t)
000000  4901              LDR      r1,|L25.8|
;;;77     {
;;;78     	counter_systick = t;
000002  6088              STR      r0,[r1,#8]  ; counter_systick
;;;79     }
000004  4770              BX       lr
;;;80     
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;90     
;;;91     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L26.8|
;;;92     {
;;;93     	counter_tick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_tick
;;;94     }
000004  4770              BX       lr
;;;95     
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      ||.data||

                          AREA ||i.systick_counter||, CODE, READONLY, ALIGN=2

                  systick_counter PROC
;;;65     
;;;66     void systick_counter(void)
000000  4802              LDR      r0,|L27.12|
;;;67     {
;;;68     	counter_systick++;
000002  6881              LDR      r1,[r0,#8]  ; counter_systick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; counter_systick
;;;69     }
000008  4770              BX       lr
;;;70     
                          ENDP

00000a  0000              DCW      0x0000
                  |L27.12|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;80     
;;;81     void tick_counter(void)
000000  4802              LDR      r0,|L28.12|
;;;82     {
;;;83     	counter_tick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_tick
;;;84     }
000008  4770              BX       lr
;;;85     
                          ENDP

00000a  0000              DCW      0x0000
                  |L28.12|
                          DCD      ||.data||

                          AREA ||i.write_magic_tag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  write_magic_tag PROC
;;;290    
;;;291    void write_magic_tag(uint8_t tag)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293        flag_check_ISP_process = tag;    
000002  4903              LDR      r1,|L29.16|
;;;294    
;;;295        printf("Write MagicTag <0x%02X>\r\n", tag);
000004  6008              STR      r0,[r1,#0]  ; flag_check_ISP_process
000006  4601              MOV      r1,r0
000008  a002              ADR      r0,|L29.20|
00000a  f7fffffe          BL       __2printf
;;;296    }
00000e  bd10              POP      {r4,pc}
;;;297    
                          ENDP

                  |L29.16|
                          DCD      ||.ARM.__AT_0x20001FFC||
                  |L29.20|
000014  57726974          DCB      "Write MagicTag <0x%02X>\r\n",0
000018  65204d61
00001c  67696354
000020  6167203c
000024  30782530
000028  32583e0d
00002c  0a00    
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||.ARM.__AT_0x00003200||, DATA, READONLY, ALIGN=0

                  FW_Version
000000  46575f56          DCB      0x46,0x57,0x5f,0x56
000004  45525f56          DCB      0x45,0x52,0x5f,0x56
000008  3030322e          DCB      0x30,0x30,0x32,0x2e
00000c  30303200          DCB      0x30,0x30,0x32,0x00

                          AREA ||.ARM.__AT_0x20001FFC||, DATA, NOINIT, ALIGN=2

                  flag_check_ISP_process
                          %        4

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000004  6172655f          DCB      0x61,0x72,0x65,0x5f
000008  62756666          DCB      0x62,0x75,0x66,0x66
00000c  657200            DCB      0x65,0x72,0x00
                  |symbol_number.92|
00000f  53                DCB      0x53
000010  79735469          DCB      0x79,0x73,0x54,0x69
000014  636b5f48          DCB      0x63,0x6b,0x5f,0x48
000018  616e646c          DCB      0x61,0x6e,0x64,0x6c
00001c  657200            DCB      0x65,0x72,0x00
                  |symbol_number.93|
00001f  54                DCB      0x54
000020  4d52315f          DCB      0x4d,0x52,0x31,0x5f
000024  49525148          DCB      0x49,0x52,0x51,0x48
000028  616e646c          DCB      0x61,0x6e,0x64,0x6c
00002c  657200            DCB      0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  counter_systick
                          DCD      0x00000000
                  LOG
                          DCD      0x00000000
                  |symbol_number.95|
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 132
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
